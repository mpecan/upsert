package io.github.mpecan.upsert.dialect

import io.github.mpecan.upsert.bean.ExtendedBeanPropertySqlParameterSource
import io.github.mpecan.upsert.model.ColumnInfo
import io.github.mpecan.upsert.model.ConditionalInfo
import io.github.mpecan.upsert.model.UpsertModel
import io.github.mpecan.upsert.type.TypeMapperRegistry
import org.springframework.beans.PropertyAccessorFactory
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate
import org.springframework.jdbc.support.GeneratedKeyHolder
import java.sql.Types

/**
 * PostgreSQL implementation of the UpsertDialect interface.
 * Uses the "INSERT ... ON CONFLICT ... DO UPDATE" syntax for upsert operations.
 */
class PostgreSqlUpsertDialect(private val typeMapperRegistry: TypeMapperRegistry) : UpsertDialect {
    /**
     * Generate a batch upsert SQL statement for PostgreSQL.
     * Uses the "INSERT ... VALUES (...) ON CONFLICT ... DO UPDATE" syntax.
     * Does not include a RETURNING clause, as generated keys will be handled by GeneratedKeyHolder.
     *
     * @param tableName The name of the table
     * @param keyColumns The columns to use as keys for the upsert operation
     * @param valueColumns The columns to update during the upsert operation
     * @param updateColumns The columns to update on conflict
     * @param batchSize The number of entities in the batch
     * @param conditionalInfo Optional conditional information for when updates should occur
     * @return The generated SQL statement
     */
    override fun generateBatchUpsertSql(
        tableName: String,
        keyColumns: List<ColumnInfo>,
        valueColumns: List<ColumnInfo>,
        updateColumns: List<ColumnInfo>,
        batchSize: Int,
        conditionalInfo: ConditionalInfo?
    ): String {

        val insertClause = "INSERT INTO $tableName (${
            valueColumns.map { it.name }.joinToString(", ")
        }) VALUES (${
            valueColumns.map { column -> ":${column.fieldName}" }.joinToString(", ")
        })"

        val onConflictClause = if (updateColumns.isEmpty()) {
            "ON CONFLICT (${keyColumns.map { it.name }.joinToString(", ")}) DO NOTHING"
        } else {
            val updateSet = updateColumns.joinToString(", ") { "${it.name} = EXCLUDED.${it.name}" }
            val conditionalClause = conditionalInfo?.let {
                // Find the column info for the conditional field
                val conditionalColumn = valueColumns.find { col -> col.fieldName == it.fieldName || col.name == it.fieldName }
                val conditionalColumnName = conditionalColumn?.name ?: it.fieldName
                " WHERE EXCLUDED.$conditionalColumnName ${it.operator.sqlOperator} $tableName.$conditionalColumnName"
            } ?: ""
            "ON CONFLICT (${keyColumns.map { it.name }.joinToString(", ")}) DO UPDATE SET $updateSet$conditionalClause"
        }

        return "$insertClause $onConflictClause"
    }

    /**
     * Executes an upsert operation for the given entities using the provided UpsertInstance.
     * This method handles all database-specific differences in the upsert operation.
     *
     * @param upsertInstance The UpsertInstance containing the table name, key columns, value columns, and update columns
     * @param entities The list of entities to upsert
     * @param jdbcTemplate The NamedParameterJdbcTemplate to use for executing the SQL
     * @return The list of updated entities with any autogenerated fields
     */
    override fun <T : Any> upsertData(
        upsertInstance: UpsertModel.UpsertInstance,
        entities: List<T>,
        jdbcTemplate: NamedParameterJdbcTemplate
    ): List<T> {
        if (entities.isEmpty()) {
            return emptyList()
        }

        // Create parameter sources for entities with IDs
        val paramSources = entities.map { entity ->
            entity to ExtendedBeanPropertySqlParameterSource(entity, typeMapperRegistry)
        }
        // Find ID columns
        val idColumns = upsertInstance.onColumns.filter { it.generated }
        val (withId, withoutId) = paramSources.partition { (_, it) ->
            idColumns.all { column ->
                column.fieldName.let { fieldName ->
                    it.hasValue(fieldName) && it.getValue(fieldName) != null
                }
            }
        }
        // Group entities based on whether they have an ID
        // Process entities with IDs
        if (withId.isNotEmpty()) {
            // Generate SQL for entities with IDs
            val sqlWithId = generateBatchUpsertSql(
                upsertInstance.tableName,
                upsertInstance.onColumns,
                upsertInstance.values,
                upsertInstance.updateColumns,
                1,
                upsertInstance.conditionalInfo
            )

            val keyHolder = GeneratedKeyHolder()
            // Execute update for entities with IDs
            jdbcTemplate.batchUpdate(sqlWithId, withId.map { it.second }.toTypedArray(), keyHolder)

            updateGeneratedKeys(keyHolder, upsertInstance, withId.map { it.first })
        }

        // Process entities without IDs
        if (withoutId.isNotEmpty()) {
            // When we don't have an ID column to use for the ON CONFLICT clause, we need to use a different approach
            // Check if there are any unique constraints on the table and use the unique constraints for the on conflict clause
            val uniqueConstraintInstance =
                upsertInstance.withoutValueColumns(idColumns).forFirstUniqueConstraint()

            // Generate SQL for entities without IDs
            val sqlWithoutId = generateBatchUpsertSql(
                uniqueConstraintInstance.tableName,
                uniqueConstraintInstance.onColumns,
                uniqueConstraintInstance.values,
                uniqueConstraintInstance.updateColumns,
                1,
                uniqueConstraintInstance.conditionalInfo
            )

            val keyHolder = GeneratedKeyHolder()
            jdbcTemplate.batchUpdate(
                sqlWithoutId,
                withoutId.map { it.second }.toTypedArray(),
                keyHolder
            )

            updateGeneratedKeys(keyHolder, upsertInstance, withoutId.map { it.first })
        }

        return entities
    }

    private fun <T : Any> updateGeneratedKeys(
        keyHolder: GeneratedKeyHolder,
        upsertInstance: UpsertModel.UpsertInstance,
        entities: List<T>
    ) {
        // Update entities with generated keys if needed
        val keysList = keyHolder.keyList.toList()

        if (keysList.isNotEmpty()) {
            // Find generated columns
            val generatedColumns = upsertInstance.values.filter { it.generated }
            entities.forEachIndexed { index, entity ->
                val beanWrapperImpl = PropertyAccessorFactory.forDirectFieldAccess(entity)
                if (index < keysList.size) {
                    val keys = keysList[index].toMap()
                    generatedColumns.forEach { column ->
                        val key = keys[column.name]
                        if (key != null) {
                           beanWrapperImpl.setPropertyValue(column.fieldName, key)
                        }
                    }
                }
            }
        }
    }

    override fun getJsonType(): Int {
        return Types.OTHER
    }
}
