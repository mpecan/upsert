package si.pecan.upsert.repository

import org.springframework.jdbc.core.*
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate
import org.springframework.jdbc.support.GeneratedKeyHolder
import si.pecan.upsert.dialect.MySqlUpsertDialect
import si.pecan.upsert.dialect.UpsertDialect
import java.lang.reflect.Field
import javax.persistence.Column
import javax.persistence.Id

/**
 * MySQL-specific implementation of UpsertOperations.
 * Uses regular batch operations with positional parameters.
 */
class MySqlJdbcUpsertOperations(
    jdbcTemplate: JdbcTemplate,
    dialect: UpsertDialect
) : AbstractJdbcUpsertOperations(jdbcTemplate, dialect) {


    /**
     * Initialize the operations with entity class and ID class.
     * For MySQL, we can pre-generate the base query template, but the VALUES part
     * depends on the number of entities in the batch.
     *
     * @param entityClass The entity class
     * @param idClass The ID class
     * @param tableName The table name
     */
    override fun initialize(entityClass: Class<*>, idClass: Class<*>, tableName: String) {
        super.initialize(entityClass, idClass, tableName)

        // Generate a query for a single entity to use as a template
        val singleEntityQuery = processor.processBatchUpsertEntity(entityClass, tableName, 1)

    }


    /**
     * Perform an upsert operation for the given list of entities.
     * Uses MySQL's regular batch operations with positional parameters.
     * Uses a pre-generated base query template for better performance.
     *
     * @param entities The list of entities to upsert
     * @param tableName The table name
     * @param <T> The entity type
     * @return The list of updated entities with any autogenerated fields
     */
    override fun <T : Any> upsertAll(entities: List<T>, tableName: String): List<T> {
        if (entities.isEmpty()) {
            return emptyList()
        }

        val entityClass = entities.first().javaClass

        // Use the pre-generated base query template if available and for the same table
        val sql = processor.processBatchUpsertEntity(entityClass, tableName, entities.size)


        // For regular batch operations, extract parameter values from all entities
        val allParamValues = entities.mapIndexed { index, entity ->
            ExtendedBeanPropertySqlParameterSource(entity)
        }.let { IndexedBeanPropertySqlParameterSource(it) }

        val keyHolder = GeneratedKeyHolder()
        // Execute the SQL with all parameters
        val namedParameterJdbcTemplate = NamedParameterJdbcTemplate(jdbcTemplate)
        namedParameterJdbcTemplate.update(sql, allParamValues, keyHolder)

        // Update entities with generated keys
        val keysList = keyHolder.keyList
        println("[DEBUG_LOG] Generated keys: $keysList")

        if (keysList.isNotEmpty()) {
            // Get the ID field from the entity class
            val idField = getKeyFields(entityClass).firstOrNull()
            println("[DEBUG_LOG] ID field: $idField, type: ${idField?.type}")

            if (idField != null) {
                // Make the field accessible
                idField.isAccessible = true

                // Update each entity with its generated key
                entities.forEachIndexed { index, entity ->
                    // Check if the entity already has an ID
                    val existingId = idField.get(entity)
                    println("[DEBUG_LOG] Entity $index existing ID: $existingId")

                    // Only set the generated key if the entity doesn't already have an ID
                    if (existingId == null && index < keysList.size) {
                        val keys = keysList[index]
                        println("[DEBUG_LOG] Keys for entity $index: $keys")

                        // Try different key names that might be used by the database
                        val possibleKeyNames = listOf("GENERATED_KEY", "GENERATED_KEYS", "id", "ID")
                        var generatedKey: Any? = null

                        for (keyName in possibleKeyNames) {
                            generatedKey = keys[keyName]
                            if (generatedKey != null) {
                                println("[DEBUG_LOG] Found generated key with name '$keyName': $generatedKey (${generatedKey.javaClass})")
                                break
                            }
                        }

                        if (generatedKey != null) {
                            try {
                                // Convert the key to the appropriate type and set it on the entity
                                val convertedKey = convertToFieldType(generatedKey, idField)
                                println("[DEBUG_LOG] Converted key: $convertedKey (${convertedKey.javaClass})")
                                idField.set(entity, convertedKey)
                                println("[DEBUG_LOG] Set ID field to: ${idField.get(entity)}")
                            } catch (e: Exception) {
                                println("[DEBUG_LOG] Error setting ID field: ${e.message}")
                                e.printStackTrace()
                            }
                        } else {
                            println("[DEBUG_LOG] No generated key found in keys: $keys")
                        }
                    } else {
                        println("[DEBUG_LOG] Entity $index already has ID: $existingId, not setting generated key")
                    }
                }
            }
        } else {
            println("[DEBUG_LOG] No keys generated")
        }

        // Fetch the entities after the upsert operation to get any generated IDs
        return fetchEntitiesAfterUpsert(entities, tableName)
    }

    /**
     * Perform an upsert operation for the given list of entities with custom ON clause and ignored fields.
     * Uses MySQL's regular batch operations with positional parameters.
     *
     * @param entities The list of entities to upsert
     * @param tableName The table name
     * @param onFields The fields to use for the ON clause
     * @param ignoredFields The fields to ignore during updates
     * @param ignoreAllFields Whether to ignore all fields during updates
     * @param <T> The entity type
     * @return The list of updated entities with any autogenerated fields
     */
    override fun <T : Any> upsertAll(
        entities: List<T>,
        tableName: String,
        onFields: List<String>,
        ignoredFields: List<String>,
        ignoreAllFields: Boolean
    ): List<T> {
        if (entities.isEmpty()) {
            return emptyList()
        }

        val entityClass = entities.first().javaClass

        // Generate the SQL for the custom upsert
        val sql = processor.processBatchUpsertEntityCustom(
            entityClass,
            tableName,
            entities.size,
            onFields,
            ignoredFields,
            ignoreAllFields
        )

        // For regular batch operations, extract parameter values from all entities
        val allParamValues = entities.flatMap { entity ->
            extractParameterValues(entity)
        }

        val keyHolder = GeneratedKeyHolder()
        // Execute the SQL with all parameters
        jdbcTemplate.update(sql, *allParamValues.toTypedArray(), keyHolder)

        // Update the entities with any generated IDs
        val updatedEntities = entities.toMutableList()
        // Fetch the entities after the upsert operation to get any generated IDs
        return fetchEntitiesAfterUpsert(entities, tableName)
    }

    /**
     * Fetch the entities after the upsert operation.
     * This is needed for MySQL since it doesn't have a RETURNING clause.
     *
     * @param entities The list of entities that were upserted
     * @param tableName The table name
     * @param <T> The entity type
     * @return The list of updated entities with any autogenerated fields
     */
    private fun <T : Any> fetchEntitiesAfterUpsert(entities: List<T>, tableName: String): List<T> {
        println("[DEBUG_LOG] Fetching entities after upsert")
        val entityClass = entities.first().javaClass
        val keyFields = getKeyFields(entityClass)
        println("[DEBUG_LOG] Key fields: $keyFields")

        if (keyFields.isEmpty()) {
            // If there are no key fields, we can't fetch the entities
            println("[DEBUG_LOG] No key fields found, returning original entities")
            return entities
        }

        // Create a row mapper for the entity class
        val rowMapper = createEntityRowMapper(entityClass)

        // Fetch each entity by its key fields
        return entities.mapIndexed { index, entity ->
            println("[DEBUG_LOG] Processing entity $index: $entity")
            try {
                // Build a WHERE clause for the key fields
                val whereClause = keyFields.joinToString(" AND ") { field ->
                    field.isAccessible = true
                    val value = field.get(entity)
                    println("[DEBUG_LOG] Key field ${field.name} value: $value")
                    "${getColumnName(field)} = ?"
                }

                // Extract the key values
                val keyValues = keyFields.map { field ->
                    field.isAccessible = true
                    val value = field.get(entity)
                    println("[DEBUG_LOG] Key value for ${field.name}: $value")
                    value
                }.toTypedArray()

                // Execute the query
                val sql = "SELECT * FROM $tableName WHERE $whereClause"
                println("[DEBUG_LOG] Executing SQL: $sql with values: ${keyValues.joinToString()}")

                val result = try {
                    jdbcTemplate.query(sql, rowMapper, *keyValues)
                } catch (e: Exception) {
                    println("[DEBUG_LOG] Error executing query: ${e.message}")
                    e.printStackTrace()
                    emptyList()
                }

                println("[DEBUG_LOG] Query result size: ${result.size}")

                // Return the fetched entity or the original if not found
                if (result.isNotEmpty()) {
                    println("[DEBUG_LOG] Returning fetched entity: ${result[0]}")
                    result[0]
                } else {
                    println("[DEBUG_LOG] No entity found, returning original: $entity")
                    entity
                }
            } catch (e: Exception) {
                println("[DEBUG_LOG] Error fetching entity: ${e.message}")
                e.printStackTrace()
                entity
            }
        }
    }

    /**
     * Create a row mapper for the given entity class.
     *
     * @param entityClass The entity class
     * @return A row mapper for the entity class
     */
    private fun <T> createEntityRowMapper(entityClass: Class<T>): RowMapper<T> {
        return RowMapper { rs, _ ->
            // Create a new instance of the entity class
            val entity = entityClass.getDeclaredConstructor().newInstance()

            // Get all fields from the entity class
            val fields = entityClass.declaredFields

            // Set the field values from the result set
            for (field in fields) {
                field.isAccessible = true
                val columnName = getColumnName(field)

                try {
                    // Check if the column exists in the result set
                    try {
                        rs.findColumn(columnName)
                    } catch (e: Exception) {
                        // Column doesn't exist, skip it
                        continue
                    }

                    // Check if the value is NULL in the database
                    val isNull = rs.wasNull() || rs.getObject(columnName) == null

                    if (isNull) {
                        // If the value is NULL in the database, set the field to null
                        field.set(entity, null)
                    } else {
                        // Get the value from the result set
                        val value = rs.getObject(columnName)

                        // Convert empty strings to null for String fields if they're nullable
                        if (value is String && value.isEmpty() && field.type == String::class.java) {
                            // Check if the field is nullable
                            val isNullable = field.type.isPrimitive.not() && field.type != String::class.java
                            if (isNullable) {
                                field.set(entity, null)
                                continue
                            }
                        }

                        // Convert the value to the field type if necessary
                        val convertedValue = convertToFieldType(value, field)
                        field.set(entity, convertedValue)
                    }
                } catch (e: Exception) {
                    println("[DEBUG_LOG] Error setting field ${field.name}: ${e.message}")
                    // Ignore if there's an error setting the field
                }
            }

            entity
        }
    }

    /**
     * Convert a value to the field type if necessary.
     *
     * @param value The value to convert
     * @param field The field to convert to
     * @return The converted value
     */
    private fun convertToFieldType(value: Any, field: Field): Any {
        // Handle common type conversions
        return when {
            field.type == Int::class.java && value is Number -> value.toInt()
            field.type == Long::class.java && value is Number -> value.toLong()
            field.type == Long::class.javaObjectType && value is Number -> value.toLong()
            field.type == Double::class.java && value is Number -> value.toDouble()
            field.type == Float::class.java && value is Number -> value.toFloat()
            field.type == Boolean::class.java && value is Boolean -> value
            field.type == String::class.java && value is String -> value
            field.type == java.math.BigInteger::class.java && value is Number -> java.math.BigInteger.valueOf(value.toLong())
            else -> value // Return as is for other types
        }
    }

    /**
     * Extract the VALUES part from a batch query by comparing it with a single-entity query.
     *
     * @param singleEntityQuery The query for a single entity
     * @param batchQuery The query for the batch
     * @return The VALUES part of the batch query
     */
    private fun extractValuesPart(singleEntityQuery: String, batchQuery: String): String {
        // Find the VALUES part in both queries
        val singleValuesIndex = singleEntityQuery.indexOf(" VALUES ")
        val batchValuesIndex = batchQuery.indexOf(" VALUES ")

        if (singleValuesIndex == -1 || batchValuesIndex == -1) {
            return ""
        }

        // Find the ON DUPLICATE KEY UPDATE part in both queries
        val singleOnDuplicateIndex = singleEntityQuery.indexOf(" ON DUPLICATE KEY UPDATE ")
        val batchOnDuplicateIndex = batchQuery.indexOf(" ON DUPLICATE KEY UPDATE ")

        if (singleOnDuplicateIndex == -1 || batchOnDuplicateIndex == -1) {
            return ""
        }

        // Extract the VALUES part from the batch query
        return batchQuery.substring(batchValuesIndex + " VALUES ".length, batchOnDuplicateIndex)
    }

    companion object {
        /**
         * Factory method to create a MySqlJdbcUpsertOperations instance.
         *
         * @param jdbcTemplate The JdbcTemplate to use
         * @return A new MySqlJdbcUpsertOperations instance
         */
        fun create(jdbcTemplate: JdbcTemplate): MySqlJdbcUpsertOperations {
            return MySqlJdbcUpsertOperations(jdbcTemplate, MySqlUpsertDialect())
        }
    }
}
