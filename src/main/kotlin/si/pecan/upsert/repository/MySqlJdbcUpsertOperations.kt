package si.pecan.upsert.repository

import org.springframework.jdbc.core.JdbcTemplate
import org.springframework.jdbc.core.RowMapper
import si.pecan.upsert.dialect.MySqlUpsertDialect
import si.pecan.upsert.dialect.UpsertDialect
import java.lang.reflect.Field
import javax.persistence.Column
import javax.persistence.Id

/**
 * MySQL-specific implementation of UpsertOperations.
 * Uses regular batch operations with positional parameters.
 */
class MySqlJdbcUpsertOperations(
    jdbcTemplate: JdbcTemplate,
    dialect: UpsertDialect
) : AbstractJdbcUpsertOperations(jdbcTemplate, dialect) {

    // Store the pre-generated base query
    private var baseQueryTemplate: String? = null

    /**
     * Initialize the operations with entity class and ID class.
     * For MySQL, we can pre-generate the base query template, but the VALUES part
     * depends on the number of entities in the batch.
     *
     * @param entityClass The entity class
     * @param idClass The ID class
     * @param tableName The table name
     */
    override fun initialize(entityClass: Class<*>, idClass: Class<*>, tableName: String) {
        super.initialize(entityClass, idClass, tableName)

        // Generate a query for a single entity to use as a template
        val singleEntityQuery = processor.processBatchUpsertEntity(entityClass, tableName, 1)

        // Extract the base query template (everything except the VALUES part)
        // The template will have a placeholder for the VALUES part
        baseQueryTemplate = extractBaseQueryTemplate(singleEntityQuery)
    }

    /**
     * Extract the base query template from a single-entity query.
     * This removes the VALUES part and replaces it with a placeholder.
     *
     * @param singleEntityQuery The query for a single entity
     * @return The base query template
     */
    private fun extractBaseQueryTemplate(singleEntityQuery: String): String {
        // Find the VALUES part
        val valuesIndex = singleEntityQuery.indexOf(" VALUES ")
        if (valuesIndex == -1) {
            return singleEntityQuery
        }

        // Extract the part before VALUES
        val beforeValues = singleEntityQuery.substring(0, valuesIndex + " VALUES ".length)

        // Find the ON DUPLICATE KEY UPDATE part
        val onDuplicateIndex = singleEntityQuery.indexOf(" ON DUPLICATE KEY UPDATE ")
        if (onDuplicateIndex == -1) {
            return beforeValues + "%VALUES_PLACEHOLDER%"
        }

        // Extract the part after the first set of values
        val afterValues = singleEntityQuery.substring(onDuplicateIndex)

        // Combine the parts with a placeholder for the VALUES part
        return beforeValues + "%VALUES_PLACEHOLDER%" + afterValues
    }

    /**
     * Perform an upsert operation for the given list of entities.
     * Uses MySQL's regular batch operations with positional parameters.
     * Uses a pre-generated base query template for better performance.
     *
     * @param entities The list of entities to upsert
     * @param tableName The table name
     * @param <T> The entity type
     * @return The list of updated entities with any autogenerated fields
     */
    override fun <T : Any> upsertAll(entities: List<T>, tableName: String): List<T> {
        if (entities.isEmpty()) {
            return emptyList()
        }

        val entityClass = entities.first().javaClass

        // Use the pre-generated base query template if available and for the same table
        val sql = if (baseQueryTemplate != null && this.tableName == tableName) {
            // Generate the VALUES part for the current batch size
            val singleEntityQuery = processor.processBatchUpsertEntity(entityClass, tableName, 1)
            val batchQuery = processor.processBatchUpsertEntity(entityClass, tableName, entities.size)

            // Extract the VALUES part from the batch query
            val valuesPart = extractValuesPart(singleEntityQuery, batchQuery)

            // Replace the placeholder with the actual VALUES part
            baseQueryTemplate!!.replace("%VALUES_PLACEHOLDER%", valuesPart)
        } else {
            // Fall back to generating the full query
            processor.processBatchUpsertEntity(entityClass, tableName, entities.size)
        }

        // For regular batch operations, extract parameter values from all entities
        val allParamValues = entities.flatMap { entity -> 
            extractParameterValues(entity)
        }

        // Execute the SQL with all parameters
        jdbcTemplate.update(sql, *allParamValues.toTypedArray())

        // According to the issue description, we only want to support generated keys,
        // not returning the entire entity. So we just return the original entities.
        return entities
    }

    /**
     * Perform an upsert operation for the given list of entities with custom ON clause and ignored fields.
     * Uses MySQL's regular batch operations with positional parameters.
     *
     * @param entities The list of entities to upsert
     * @param tableName The table name
     * @param onFields The fields to use for the ON clause
     * @param ignoredFields The fields to ignore during updates
     * @param ignoreAllFields Whether to ignore all fields during updates
     * @param <T> The entity type
     * @return The list of updated entities with any autogenerated fields
     */
    override fun <T : Any> upsertAll(
        entities: List<T>,
        tableName: String,
        onFields: List<String>,
        ignoredFields: List<String>,
        ignoreAllFields: Boolean
    ): List<T> {
        if (entities.isEmpty()) {
            return emptyList()
        }

        val entityClass = entities.first().javaClass

        // Generate the SQL for the custom upsert
        val sql = processor.processBatchUpsertEntityCustom(
            entityClass,
            tableName,
            entities.size,
            onFields,
            ignoredFields,
            ignoreAllFields
        )

        // For regular batch operations, extract parameter values from all entities
        val allParamValues = entities.flatMap { entity -> 
            extractParameterValues(entity)
        }

        // Execute the SQL with all parameters
        jdbcTemplate.update(sql, *allParamValues.toTypedArray())

        // According to the issue description, we only want to support generated keys,
        // not returning the entire entity. So we just return the original entities.
        return entities
    }

    /**
     * Fetch the entities after the upsert operation.
     * This is needed for MySQL since it doesn't have a RETURNING clause.
     *
     * @param entities The list of entities that were upserted
     * @param tableName The table name
     * @param <T> The entity type
     * @return The list of updated entities with any autogenerated fields
     */
    private fun <T : Any> fetchEntitiesAfterUpsert(entities: List<T>, tableName: String): List<T> {
        val entityClass = entities.first().javaClass
        val keyFields = getKeyFields(entityClass)

        if (keyFields.isEmpty()) {
            // If there are no key fields, we can't fetch the entities
            return entities
        }

        // Create a row mapper for the entity class
        val rowMapper = createEntityRowMapper(entityClass)

        // Fetch each entity by its key fields
        return entities.map { entity ->
            // Build a WHERE clause for the key fields
            val whereClause = keyFields.joinToString(" AND ") { field ->
                field.isAccessible = true
                val value = field.get(entity)
                "${getColumnName(field)} = ?"
            }

            // Extract the key values
            val keyValues = keyFields.map { field ->
                field.isAccessible = true
                field.get(entity)
            }.toTypedArray()

            // Execute the query
            val sql = "SELECT * FROM $tableName WHERE $whereClause"
            val result = jdbcTemplate.query(sql, rowMapper, *keyValues)

            // Return the fetched entity or the original if not found
            if (result.isNotEmpty()) result[0] else entity
        }
    }

    /**
     * Create a row mapper for the given entity class.
     *
     * @param entityClass The entity class
     * @return A row mapper for the entity class
     */
    private fun <T> createEntityRowMapper(entityClass: Class<T>): RowMapper<T> {
        return RowMapper { rs, _ ->
            // Create a new instance of the entity class
            val entity = entityClass.getDeclaredConstructor().newInstance()

            // Get all fields from the entity class
            val fields = entityClass.declaredFields

            // Set the field values from the result set
            for (field in fields) {
                field.isAccessible = true
                val columnName = getColumnName(field)

                try {
                    // Get the value from the result set
                    val value = rs.getObject(columnName)

                    // Set the field value if not null
                    if (value != null) {
                        // Convert the value to the field type if necessary
                        val convertedValue = convertToFieldType(value, field)
                        field.set(entity, convertedValue)
                    }
                } catch (e: Exception) {
                    // Ignore if the column doesn't exist in the result set
                }
            }

            entity
        }
    }

    /**
     * Convert a value to the field type if necessary.
     *
     * @param value The value to convert
     * @param field The field to convert to
     * @return The converted value
     */
    private fun convertToFieldType(value: Any, field: Field): Any {
        // Handle common type conversions
        return when {
            field.type == Int::class.java && value is Number -> value.toInt()
            field.type == Long::class.java && value is Number -> value.toLong()
            field.type == Double::class.java && value is Number -> value.toDouble()
            field.type == Float::class.java && value is Number -> value.toFloat()
            field.type == Boolean::class.java && value is Boolean -> value
            field.type == String::class.java && value is String -> value
            else -> value // Return as is for other types
        }
    }

    /**
     * Extract the VALUES part from a batch query by comparing it with a single-entity query.
     *
     * @param singleEntityQuery The query for a single entity
     * @param batchQuery The query for the batch
     * @return The VALUES part of the batch query
     */
    private fun extractValuesPart(singleEntityQuery: String, batchQuery: String): String {
        // Find the VALUES part in both queries
        val singleValuesIndex = singleEntityQuery.indexOf(" VALUES ")
        val batchValuesIndex = batchQuery.indexOf(" VALUES ")

        if (singleValuesIndex == -1 || batchValuesIndex == -1) {
            return ""
        }

        // Find the ON DUPLICATE KEY UPDATE part in both queries
        val singleOnDuplicateIndex = singleEntityQuery.indexOf(" ON DUPLICATE KEY UPDATE ")
        val batchOnDuplicateIndex = batchQuery.indexOf(" ON DUPLICATE KEY UPDATE ")

        if (singleOnDuplicateIndex == -1 || batchOnDuplicateIndex == -1) {
            return ""
        }

        // Extract the VALUES part from the batch query
        return batchQuery.substring(batchValuesIndex + " VALUES ".length, batchOnDuplicateIndex)
    }

    companion object {
        /**
         * Factory method to create a MySqlJdbcUpsertOperations instance.
         *
         * @param jdbcTemplate The JdbcTemplate to use
         * @return A new MySqlJdbcUpsertOperations instance
         */
        fun create(jdbcTemplate: JdbcTemplate): MySqlJdbcUpsertOperations {
            return MySqlJdbcUpsertOperations(jdbcTemplate, MySqlUpsertDialect())
        }
    }
}
