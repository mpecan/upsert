package si.pecan.upsert.repository

import org.springframework.jdbc.core.JdbcTemplate
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate
import org.springframework.jdbc.support.GeneratedKeyHolder
import si.pecan.upsert.dialect.PostgreSqlUpsertDialect
import si.pecan.upsert.dialect.UpsertDialect
import java.lang.reflect.Field
import si.pecan.upsert.model.UpsertModel

/**
 * PostgreSQL-specific implementation of UpsertOperations.
 * Uses the optimized batch operations with named parameters.
 */
class PostgreSqlJdbcUpsertOperations(
    jdbcTemplate: JdbcTemplate,
    dialect: UpsertDialect
) : AbstractJdbcUpsertOperations(jdbcTemplate, dialect) {

    // Store the pre-generated SQL query
    private var preGeneratedSql: String? = null

    /**
     * Initialize the operations with entity class and ID class.
     * For PostgreSQL, we can generate the entire SQL query at startup.
     *
     * @param entityClass The entity class
     * @param idClass The ID class
     * @param tableName The table name
     */
    override fun initialize(upsertModel: UpsertModel) {
        super.initialize(upsertModel)

        // Generate the SQL for a single entity
        preGeneratedSql = processor.processBatchUpsertEntity(upsertModel, 1)
    }

    /**
     * Perform an upsert operation for the given list of entities.
     * Uses PostgreSQL's optimized batch operations with named parameters.
     * Uses a pre-generated SQL query for better performance.
     *
     * @param entities The list of entities to upsert
     * @param tableName The table name
     * @param <T> The entity type
     * @return The list of updated entities with any autogenerated fields
     */
    override fun <T : Any> upsertAll(entities: List<T>, tableName: String): List<T> {
        if (entities.isEmpty()) {
            return emptyList()
        }
        val sql = processor.processBatchUpsertEntity(upsertModel, 1)
        return executeUpsertAndReturnEntities(entities, sql)
    }

    /**
     * Perform an upsert operation for the given list of entities with custom ON clause and ignored fields.
     * Uses PostgreSQL's optimized batch operations with named parameters.
     *
     * @param entities The list of entities to upsert
     * @param tableName The table name
     * @param onFields The fields to use for the ON clause
     * @param ignoredFields The fields to ignore during updates
     * @param ignoreAllFields Whether to ignore all fields during updates
     * @param <T> The entity type
     * @return The list of updated entities with any autogenerated fields
     */
    override fun <T : Any> upsertAll(
        entities: List<T>,
        tableName: String,
        onFields: List<String>,
        ignoredFields: List<String>,
        ignoreAllFields: Boolean
    ): List<T> {
        if (entities.isEmpty()) {
            return emptyList()
        }

        // Generate the SQL for the custom upsert
        val sql = processor.processBatchUpsertEntityCustom(
            upsertModel,
            1,
            onFields,
            ignoredFields,
            ignoreAllFields
        )

        return executeUpsertAndReturnEntities(entities, sql)
    }

    /**
     * Execute the upsert operation and fetch the entities after the upsert.
     * This is needed to get any generated IDs.
     *
     * @param entities The list of entities to upsert
     * @param sql The SQL query to execute
     * @param <T> The entity type
     * @return The list of updated entities with any generated IDs
     */
    private fun <T : Any> executeUpsertAndReturnEntities(entities: List<T>, sql: String): List<T> {
        // Create parameter sources for each entity
        val paramSources = entities.map { entity ->
            ExtendedBeanPropertySqlParameterSource(entity)
        }.toTypedArray()

        // Create a NamedParameterJdbcTemplate
        val namedJdbcTemplate = NamedParameterJdbcTemplate(jdbcTemplate)


        val keyHolder = GeneratedKeyHolder()
        namedJdbcTemplate.batchUpdate(sql, paramSources, keyHolder)
        keyHolder.keyList.forEachIndexed { index, keys ->
            val entity = entities[index]

        }

        // Fetch the entities after the upsert operation to get any generated IDs
        return entities
    }

    /**
     * Convert a value to the field type if necessary.
     *
     * @param value The value to convert
     * @param field The field to convert to
     * @return The converted value
     */
    private fun convertToFieldType(value: Any, field: Field): Any {
        // Handle common type conversions
        return when {
            field.type == Int::class.java && value is Number -> value.toInt()
            field.type == Long::class.java && value is Number -> value.toLong()
            field.type == Long::class.javaObjectType && value is Number -> value.toLong()
            field.type == Double::class.java && value is Number -> value.toDouble()
            field.type == Float::class.java && value is Number -> value.toFloat()
            field.type == Boolean::class.java && value is Boolean -> value
            field.type == String::class.java && value is String -> value
            field.type == java.math.BigInteger::class.java && value is Number -> java.math.BigInteger.valueOf(
                value.toLong()
            )

            else -> value // Return as is for other types
        }
    }

    companion object {
        /**
         * Factory method to create a PostgreSqlJdbcUpsertOperations instance.
         *
         * @param jdbcTemplate The JdbcTemplate to use
         * @return A new PostgreSqlJdbcUpsertOperations instance
         */
        fun create(jdbcTemplate: JdbcTemplate): PostgreSqlJdbcUpsertOperations {
            return PostgreSqlJdbcUpsertOperations(jdbcTemplate, PostgreSqlUpsertDialect())
        }
    }
}
