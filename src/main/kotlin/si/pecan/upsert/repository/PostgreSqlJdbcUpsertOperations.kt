package si.pecan.upsert.repository

import org.springframework.jdbc.core.JdbcTemplate
import org.springframework.jdbc.core.RowMapper
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate
import si.pecan.upsert.dialect.PostgreSqlUpsertDialect
import si.pecan.upsert.dialect.UpsertDialect
import java.lang.reflect.Field
import javax.persistence.Column

/**
 * PostgreSQL-specific implementation of UpsertOperations.
 * Uses the optimized batch operations with named parameters.
 */
class PostgreSqlJdbcUpsertOperations(
    jdbcTemplate: JdbcTemplate,
    dialect: UpsertDialect
) : AbstractJdbcUpsertOperations(jdbcTemplate, dialect) {

    // Store the pre-generated SQL query
    private var preGeneratedSql: String? = null

    /**
     * Initialize the operations with entity class and ID class.
     * For PostgreSQL, we can generate the entire SQL query at startup.
     *
     * @param entityClass The entity class
     * @param idClass The ID class
     * @param tableName The table name
     */
    override fun initialize(entityClass: Class<*>, idClass: Class<*>, tableName: String) {
        super.initialize(entityClass, idClass, tableName)

        // Generate the SQL for a single entity
        preGeneratedSql = processor.processBatchUpsertEntity(entityClass, tableName, 1)
    }

    /**
     * Perform an upsert operation for the given list of entities.
     * Uses PostgreSQL's optimized batch operations with named parameters.
     * Uses a pre-generated SQL query for better performance.
     *
     * @param entities The list of entities to upsert
     * @param tableName The table name
     * @param <T> The entity type
     * @return The list of updated entities with any autogenerated fields
     */
    override fun <T : Any> upsertAll(entities: List<T>, tableName: String): List<T> {
        if (entities.isEmpty()) {
            return emptyList()
        }

        // Use the pre-generated SQL if available, otherwise generate it
        val sql = if (preGeneratedSql != null && this.tableName == tableName) {
            preGeneratedSql!!
        } else {
            val entityClass = entities.first().javaClass
            processor.processBatchUpsertEntity(entityClass, tableName, 1)
        }

        return executeUpsertAndReturnEntities(entities, sql)
    }

    /**
     * Perform an upsert operation for the given list of entities with custom ON clause and ignored fields.
     * Uses PostgreSQL's optimized batch operations with named parameters.
     *
     * @param entities The list of entities to upsert
     * @param tableName The table name
     * @param onFields The fields to use for the ON clause
     * @param ignoredFields The fields to ignore during updates
     * @param ignoreAllFields Whether to ignore all fields during updates
     * @param <T> The entity type
     * @return The list of updated entities with any autogenerated fields
     */
    override fun <T : Any> upsertAll(
        entities: List<T>,
        tableName: String,
        onFields: List<String>,
        ignoredFields: List<String>,
        ignoreAllFields: Boolean
    ): List<T> {
        if (entities.isEmpty()) {
            return emptyList()
        }

        // Generate the SQL for the custom upsert
        val entityClass = entities.first().javaClass
        val sql = processor.processBatchUpsertEntityCustom(
            entityClass,
            tableName,
            1,
            onFields,
            ignoredFields,
            ignoreAllFields
        )

        return executeUpsertAndReturnEntities(entities, sql)
    }

    /**
     * Execute the upsert operation and return the original entities.
     * According to the issue description, we only want to support generated keys,
     * not returning the entire entity.
     *
     * @param entities The list of entities to upsert
     * @param sql The SQL query to execute
     * @param <T> The entity type
     * @return The list of original entities
     */
    private fun <T : Any> executeUpsertAndReturnEntities(entities: List<T>, sql: String): List<T> {
        // Create parameter sources for each entity
        val paramSources = entities.map { entity -> 
            ExtendedBeanPropertySqlParameterSource(entity)
        }.toTypedArray()

        // Create a NamedParameterJdbcTemplate
        val namedJdbcTemplate = NamedParameterJdbcTemplate(jdbcTemplate)

        // Execute the query for each entity
        for (paramSource in paramSources) {
            namedJdbcTemplate.update(sql, paramSource)
        }

        // Simply return the original entities
        return entities
    }

    /**
     * Create a row mapper for the given entity class.
     *
     * @param entityClass The entity class
     * @return A row mapper for the entity class
     */
    private fun <T> createEntityRowMapper(entityClass: Class<T>): RowMapper<T> {
        return RowMapper { rs, _ ->
            // Create a new instance of the entity class
            val entity = entityClass.getDeclaredConstructor().newInstance()

            // Get all fields from the entity class
            val fields = entityClass.declaredFields

            // Set the field values from the result set
            for (field in fields) {
                field.isAccessible = true
                val columnName = getColumnName(field)

                try {
                    // Get the value from the result set
                    val value = rs.getObject(columnName)

                    // Set the field value if not null
                    if (value != null) {
                        // Convert the value to the field type if necessary
                        val convertedValue = convertToFieldType(value, field)
                        field.set(entity, convertedValue)
                    }
                } catch (e: Exception) {
                    // Ignore if the column doesn't exist in the result set
                }
            }

            entity
        }
    }

    /**
     * Convert a value to the field type if necessary.
     *
     * @param value The value to convert
     * @param field The field to convert to
     * @return The converted value
     */
    private fun convertToFieldType(value: Any, field: Field): Any {
        // Handle common type conversions
        return when {
            field.type == Int::class.java && value is Number -> value.toInt()
            field.type == Long::class.java && value is Number -> value.toLong()
            field.type == Double::class.java && value is Number -> value.toDouble()
            field.type == Float::class.java && value is Number -> value.toFloat()
            field.type == Boolean::class.java && value is Boolean -> value
            field.type == String::class.java && value is String -> value
            else -> value // Return as is for other types
        }
    }

    companion object {
        /**
         * Factory method to create a PostgreSqlJdbcUpsertOperations instance.
         *
         * @param jdbcTemplate The JdbcTemplate to use
         * @return A new PostgreSqlJdbcUpsertOperations instance
         */
        fun create(jdbcTemplate: JdbcTemplate): PostgreSqlJdbcUpsertOperations {
            return PostgreSqlJdbcUpsertOperations(jdbcTemplate, PostgreSqlUpsertDialect())
        }
    }
}
