package si.pecan.upsert.dialect

import org.springframework.beans.PropertyAccessorFactory
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate
import org.springframework.jdbc.support.GeneratedKeyHolder
import si.pecan.upsert.bean.ExtendedBeanPropertySqlParameterSource
import si.pecan.upsert.bean.IndexedBeanPropertySqlParameterSource
import si.pecan.upsert.model.UpsertModel

/**
 * MySQL implementation of the UpsertDialect interface.
 * Uses the "INSERT ... ON DUPLICATE KEY UPDATE" syntax for upsert operations.
 */
class MySqlUpsertDialect : UpsertDialect {

    /**
     * Generate a batch upsert SQL statement for MySQL.
     * Uses the "INSERT ... VALUES (...), (...), ... ON DUPLICATE KEY UPDATE" syntax.
     *
     * @param tableName The name of the table
     * @param keyColumns The columns to use as keys for the upsert operation
     * @param valueColumns The columns to update during the upsert operation
     * @param batchSize The number of entities in the batch
     * @return The generated SQL statement
     */
    override fun generateBatchUpsertSql(
        tableName: String,
        keyColumns: List<ColumnInfo>,
        valueColumns: List<ColumnInfo>,
        updateColumns: List<ColumnInfo>,
        batchSize: Int
    ): String {

        // Create placeholders for all entities in the batch
        val allPlaceholders = (1..batchSize).joinToString(", ") {
            "(${valueColumns.map { column -> ":${column.name}_${it}" }.joinToString(", ")})"
        }

        val insertClause =
            "INSERT INTO $tableName (${valueColumns.joinToString(", ") { it.name }}) VALUES $allPlaceholders"

        val updateClause = if (updateColumns.isEmpty()) {
            // If no columns to update, use a dummy update that effectively does nothing
            // by setting a key column to its current value
            if (keyColumns.isNotEmpty()) {
                "${keyColumns.first().name} = ${keyColumns.first().name}"
            } else {
                // Fallback if no key columns are provided
                "1=1"
            }
        } else {
            updateColumns.joinToString(", ") { "${it.name} = VALUES(${it.name})" }
        }

        return "$insertClause ON DUPLICATE KEY UPDATE $updateClause"
    }

    /**
     * Executes an upsert operation for the given entities using the provided UpsertInstance.
     * This method handles all database-specific differences in the upsert operation.
     *
     * @param upsertInstance The UpsertInstance containing the table name, key columns, value columns, and update columns
     * @param entities The list of entities to upsert
     * @param jdbcTemplate The NamedParameterJdbcTemplate to use for executing the SQL
     * @return The list of updated entities with any autogenerated fields
     */
    override fun <T : Any> upsertData(
        upsertInstance: UpsertModel.UpsertInstance,
        entities: List<T>,
        jdbcTemplate: NamedParameterJdbcTemplate
    ): List<T> {
        if (entities.isEmpty()) {
            return emptyList()
        }

        // Generate the SQL for the batch
        val sql = generateBatchUpsertSql(
            upsertInstance.tableName,
            upsertInstance.onColumns,
            upsertInstance.values,
            upsertInstance.updateColumns,
            entities.size
        )

        // For MySQL, we need to create parameter sources with indexed names
        val allParamValues = entities.mapIndexed { index, entity ->
            ExtendedBeanPropertySqlParameterSource(entity)
        }.let { IndexedBeanPropertySqlParameterSource(it) }

        val keyHolder = GeneratedKeyHolder()
        // Execute the SQL with all parameters
        jdbcTemplate.update(sql, allParamValues, keyHolder)

        // Update entities with generated keys if needed
        val keysList = keyHolder.keyList

        if (keysList.isNotEmpty()) {
            // Find generated columns
            val generatedColumns = upsertInstance.values.filter { it.generated }

            entities.forEachIndexed { index, entity ->
                if (index < keysList.size) {
                    val keys = keysList[index]
                    val beanWrapper = PropertyAccessorFactory.forDirectFieldAccess(entity)
                    for (column in generatedColumns) {
                        // Try different key names that might be used by the database
                        val possibleKeyNames = listOf("GENERATED_KEY", "GENERATED_KEYS", column.name, column.name.uppercase())
                        var generatedKey: Any? = null

                        for (keyName in possibleKeyNames) {
                            generatedKey = keys[keyName]
                            if (generatedKey != null) {
                                break
                            }
                        }

                        if (generatedKey != null) {
                            try {
                                if (beanWrapper.getPropertyValue(column.fieldName) != null) {
                                    // Skip setting the generated key if the field is already set
                                    continue
                                }
                                beanWrapper.setPropertyValue(column.fieldName, generatedKey)
                            } catch (e: Exception) {
                                // Log the error but continue processing
                                println("[DEBUG_LOG] Error setting generated key: ${e.message}")
                            }
                        }
                    }
                }
            }
        }

        return entities
    }
}
