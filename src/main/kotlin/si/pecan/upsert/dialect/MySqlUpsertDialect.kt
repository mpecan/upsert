package si.pecan.upsert.dialect

import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate
import org.springframework.jdbc.support.GeneratedKeyHolder
import si.pecan.upsert.model.UpsertModel
import si.pecan.upsert.bean.ExtendedBeanPropertySqlParameterSource
import si.pecan.upsert.bean.IndexedBeanPropertySqlParameterSource
import java.lang.reflect.Field

/**
 * MySQL implementation of the UpsertDialect interface.
 * Uses the "INSERT ... ON DUPLICATE KEY UPDATE" syntax for upsert operations.
 */
class MySqlUpsertDialect : UpsertDialect {

    /**
     * Generate a batch upsert SQL statement for MySQL.
     * Uses the "INSERT ... VALUES (...), (...), ... ON DUPLICATE KEY UPDATE" syntax.
     *
     * @param tableName The name of the table
     * @param keyColumns The columns to use as keys for the upsert operation
     * @param valueColumns The columns to update during the upsert operation
     * @param batchSize The number of entities in the batch
     * @return The generated SQL statement
     */
    override fun generateBatchUpsertSql(
        tableName: String,
        keyColumns: List<ColumnInfo>,
        valueColumns: List<ColumnInfo>,
        updateColumns: List<ColumnInfo>,
        batchSize: Int
    ): String {

        // Create placeholders for all entities in the batch
        val allPlaceholders = (1..batchSize).joinToString(", ") {
            "(${valueColumns.map { column -> ":${column.name}_${it}" }.joinToString(", ")})"
        }

        val insertClause =
            "INSERT INTO $tableName (${valueColumns.joinToString(", ") { it.name }}) VALUES $allPlaceholders"

        val updateClause = updateColumns.joinToString(", ") { "${it.name} = VALUES(${it.name})" }

        return "$insertClause ON DUPLICATE KEY UPDATE $updateClause"
    }

    /**
     * Executes an upsert operation for the given entities using the provided UpsertInstance.
     * This method handles all database-specific differences in the upsert operation.
     *
     * @param upsertInstance The UpsertInstance containing the table name, key columns, value columns, and update columns
     * @param entities The list of entities to upsert
     * @param jdbcTemplate The NamedParameterJdbcTemplate to use for executing the SQL
     * @return The list of updated entities with any autogenerated fields
     */
    override fun <T : Any> upsertData(
        upsertInstance: UpsertModel.UpsertInstance,
        entities: List<T>,
        jdbcTemplate: NamedParameterJdbcTemplate
    ): List<T> {
        if (entities.isEmpty()) {
            return emptyList()
        }

        // Generate the SQL for the batch
        val sql = generateBatchUpsertSql(
            upsertInstance.tableName,
            upsertInstance.onColumns,
            upsertInstance.values,
            upsertInstance.updateColumns,
            entities.size
        )

        // For MySQL, we need to create parameter sources with indexed names
        val allParamValues = entities.mapIndexed { index, entity ->
            ExtendedBeanPropertySqlParameterSource(entity)
        }.let { IndexedBeanPropertySqlParameterSource(it) }

        val keyHolder = GeneratedKeyHolder()
        // Execute the SQL with all parameters
        jdbcTemplate.update(sql, allParamValues, keyHolder)

        // Update entities with generated keys if needed
        val keysList = keyHolder.keyList

        if (keysList.isNotEmpty()) {
            // Find generated columns
            val generatedColumns = upsertInstance.values.filter { it.generated }

            entities.forEachIndexed { index, entity ->
                if (index < keysList.size) {
                    val keys = keysList[index]

                    for (column in generatedColumns) {
                        // Try different key names that might be used by the database
                        val possibleKeyNames = listOf("GENERATED_KEY", "GENERATED_KEYS", column.name, column.name.uppercase())
                        var generatedKey: Any? = null

                        for (keyName in possibleKeyNames) {
                            generatedKey = keys[keyName]
                            if (generatedKey != null) {
                                break
                            }
                        }

                        if (generatedKey != null) {
                            try {
                                // Find the field in the entity class
                                val field = entity.javaClass.getDeclaredField(column.fieldName)
                                field.isAccessible = true

                                // Only set the field if it's null
                                if (field.get(entity) == null) {
                                    field.set(entity, convertToFieldType(generatedKey, field))
                                }
                            } catch (e: Exception) {
                                // Log the error but continue processing
                                println("[DEBUG_LOG] Error setting generated key: ${e.message}")
                            }
                        }
                    }
                }
            }
        }

        return entities
    }

    /**
     * Convert a value to the field type if necessary.
     *
     * @param value The value to convert
     * @param field The field to convert to
     * @return The converted value
     */
    private fun convertToFieldType(value: Any, field: Field): Any {
        // Handle common type conversions
        return when {
            field.type == Int::class.java && value is Number -> value.toInt()
            field.type == Long::class.java && value is Number -> value.toLong()
            field.type == Long::class.javaObjectType && value is Number -> value.toLong()
            field.type == Double::class.java && value is Number -> value.toDouble()
            field.type == Float::class.java && value is Number -> value.toFloat()
            field.type == Boolean::class.java && value is Boolean -> value
            field.type == String::class.java && value is String -> value
            field.type == java.math.BigInteger::class.java && value is Number -> java.math.BigInteger.valueOf(
                value.toLong()
            )
            else -> value // Return as is for other types
        }
    }
}
