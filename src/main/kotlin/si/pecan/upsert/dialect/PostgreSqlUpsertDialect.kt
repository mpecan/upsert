package si.pecan.upsert.dialect

import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate
import org.springframework.jdbc.support.GeneratedKeyHolder
import si.pecan.upsert.model.UpsertModel
import si.pecan.upsert.bean.ExtendedBeanPropertySqlParameterSource
import java.lang.reflect.Field

/**
 * PostgreSQL implementation of the UpsertDialect interface.
 * Uses the "INSERT ... ON CONFLICT ... DO UPDATE" syntax for upsert operations.
 */
class PostgreSqlUpsertDialect : UpsertDialect {
    /**
     * Generate a batch upsert SQL statement for PostgreSQL.
     * Uses the "INSERT ... VALUES (...) ON CONFLICT ... DO UPDATE" syntax.
     * Does not include a RETURNING clause, as generated keys will be handled by GeneratedKeyHolder.
     *
     * @param tableName The name of the table
     * @param keyColumns The columns to use as keys for the upsert operation
     * @param valueColumns The columns to update during the upsert operation
     * @param batchSize The number of entities in the batch
     * @return The generated SQL statement
     */
    override fun generateBatchUpsertSql(
        tableName: String,
        keyColumns: List<ColumnInfo>,
        valueColumns: List<ColumnInfo>,
        updateColumns: List<ColumnInfo>,
        batchSize: Int
    ): String {

        val insertClause = "INSERT INTO $tableName (${
            valueColumns.map { it.name }.joinToString(", ")
        }) VALUES (${
            valueColumns.map { column -> ":${column.fieldName}" }.joinToString(", ")
        })"

        val onConflictClause =
            "ON CONFLICT (${keyColumns.map { it.name }.joinToString(", ")}) DO UPDATE SET"

        val updateClause = updateColumns.map { it.name }.joinToString(", ") { "$it = EXCLUDED.$it" }

        return "$insertClause $onConflictClause $updateClause"
    }

    /**
     * Executes an upsert operation for the given entities using the provided UpsertInstance.
     * This method handles all database-specific differences in the upsert operation.
     *
     * @param upsertInstance The UpsertInstance containing the table name, key columns, value columns, and update columns
     * @param entities The list of entities to upsert
     * @param jdbcTemplate The NamedParameterJdbcTemplate to use for executing the SQL
     * @return The list of updated entities with any autogenerated fields
     */
    override fun <T : Any> upsertData(
        upsertInstance: UpsertModel.UpsertInstance,
        entities: List<T>,
        jdbcTemplate: NamedParameterJdbcTemplate
    ): List<T> {
        if (entities.isEmpty()) {
            return emptyList()
        }

        // Create parameter sources for entities with IDs
        val paramSources = entities.map { entity ->
            entity to ExtendedBeanPropertySqlParameterSource(entity)
        }
        // Find ID columns
        val idColumns = upsertInstance.onColumns.filter { it.generated }
        val (withId, withoutId) = paramSources.partition { (_, it) ->
            idColumns.all { column ->
                column.fieldName.let { fieldName ->
                    it.hasValue(fieldName) && it.getValue(fieldName) != null
                }
            }
        }
        // Group entities based on whether they have an ID
        // Process entities with IDs
        if (withId.isNotEmpty()) {
            // Generate SQL for entities with IDs
            val sqlWithId = generateBatchUpsertSql(
                upsertInstance.tableName,
                upsertInstance.onColumns,
                upsertInstance.values,
                upsertInstance.updateColumns,
                1
            )

            val keyHolder = GeneratedKeyHolder()
            // Execute update for entities with IDs
            jdbcTemplate.batchUpdate(sqlWithId, withId.map { it.second }.toTypedArray(), keyHolder)

            updateGeneratedKeys(keyHolder, upsertInstance, withId.map { it.first })
        }

        // Process entities without IDs
        if (withoutId.isNotEmpty()) {
            // When we don't have an ID column to use for the ON CONFLICT clause, we need to use a different approach
            // Check if there are any unique constraints on the table and use the unique constraints for the on conflict clause
            val uniqueConstraintInstance =
                upsertInstance.withoutValueColumns(idColumns).forFirstUniqueConstraint()

            // Generate SQL for entities without IDs
            val sqlWithoutId = generateBatchUpsertSql(
                uniqueConstraintInstance.tableName,
                uniqueConstraintInstance.onColumns,
                uniqueConstraintInstance.values,
                uniqueConstraintInstance.updateColumns,
                1
            )

            val keyHolder = GeneratedKeyHolder()
            jdbcTemplate.batchUpdate(
                sqlWithoutId,
                withoutId.map { it.second }.toTypedArray(),
                keyHolder
            )

            updateGeneratedKeys(keyHolder, upsertInstance, withoutId.map { it.first })
        }

        return entities
    }

    private fun <T : Any> updateGeneratedKeys(
        keyHolder: GeneratedKeyHolder,
        upsertInstance: UpsertModel.UpsertInstance,
        entities: List<T>
    ) {
        // Update entities with generated keys if needed
        val keysList = keyHolder.keyList

        if (keysList.isNotEmpty()) {
            // Find generated columns
            val generatedColumns = upsertInstance.values.filter { it.generated }

            entities.forEachIndexed { index, entity ->
                if (index < keysList.size) {
                    val keys = keysList[index]
                    generatedColumns.forEach { column ->
                        val key = keys[column.name]
                        if (key != null) {
                            val field = entity::class.java.getDeclaredField(column.fieldName)
                            field.isAccessible = true
                            field.set(entity, convertToFieldType(key, field))
                        }
                    }
                }
            }
        }
    }

    /**
     * Convert a value to the field type if necessary.
     *
     * @param value The value to convert
     * @param field The field to convert to
     * @return The converted value
     */
    private fun convertToFieldType(value: Any, field: Field): Any {
        // Handle common type conversions
        return when {
            field.type == Int::class.java && value is Number -> value.toInt()
            field.type == Long::class.java && value is Number -> value.toLong()
            field.type == Long::class.javaObjectType && value is Number -> value.toLong()
            field.type == Double::class.java && value is Number -> value.toDouble()
            field.type == Float::class.java && value is Number -> value.toFloat()
            field.type == Boolean::class.java && value is Boolean -> value
            field.type == String::class.java && value is String -> value
            field.type == java.math.BigInteger::class.java && value is Number -> java.math.BigInteger.valueOf(
                value.toLong()
            )

            else -> value // Return as is for other types
        }
    }

    /**
     * Check if this dialect supports optimized batch operations.
     * PostgreSQL supports optimized batch operations using unnest.
     *
     * @return True as PostgreSQL supports optimized batch operations
     */
    override fun supportsOptimizedBatch(): Boolean = true
}
